<!DOCTYPE html>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<meta charset='utf-8'/>
<html>
  <head>
    <title>werm</title>
<style>

html {
  height: 100%;
}
body {
  position: absolute;
  height: 100%;
  width: 100%;
  overflow: hidden;
  margin: 0px;
  padding: 0px;
}
</style>

  </head>
  <body>
    <div id="terminal"
         style="position:relative; width:100%; height:100%"></div>
    <script src="hterm_all.js"></script>
    <script>

var log_send = 0, log_display = 0, mkeys = [];

function term_init()
{
	var t, io, pend_send = '', term_ready = false, sock, pend_display = [],
		pend_escape = '', ignore_disp = '', termid, cached_title, pream,
		params, dead_key_hist;

	function display(s)
	{
		var next_esc, pend_i, c;

		function pend(di) { return pend_display[pend_i + di]; }
		function is_utf_trail(di) {
			if (0x80 == (pend(di) & 0xc0)) return true;
			t.io.print('?');
			return false;
		}

		function hex_val(i)
		{
			var c = s.charAt(i);
			if (c >= '0' && c <= '9') return s.charCodeAt(i) - 48;
			if (c >= 'a' && c <= 'f') return s.charCodeAt(i) - 87;
			throw `invalid hex at ${i} in ${s}: ${c}`
		}

		if (ignore_disp === s) s = '';
		ignore_disp = '';

		if (log_display) {
			console.log('display: ' + JSON.stringify(s));
			if (log_display > 1) console.trace();
		}

		if (pend_escape) {
			s = pend_escape + s;
			pend_escape = '';
		}

		while (true) {
			next_esc = s.indexOf('\\');
			if (next_esc === -1) next_esc = s.length;
			if (next_esc > 0) {
				pend_display.push(s.substr(0, next_esc));
				s = s.substr(next_esc);
			}

			if (!s) break;

			if (s.length < 3) {
				// Escape is incomplete, so send it later.
				pend_escape = s;
				break;
			}

			pend_display.push(hex_val(1) * 16 + hex_val(2));

			s = s.substr(3);
		}

		if (!term_ready) return;

		for (pend_i = 0; pend_i < pend_display.length; pend_i++) {
			if (typeof pend(0) === 'string') {
				t.io.print(pend(0));
				continue;
			}

			if (pend(0) < 0x80) {
				t.io.print(String.fromCharCode(pend(0)));
				continue;
			}

			c = 0;
			if (pend_display.length < 2) break;
			if (!is_utf_trail(1)) continue;
			c += pend(1) & ~0xc0;

			if (0xc0 == (pend(0) & 0xe0)) {
				c += (pend(0) & ~0xe0) << 6;
				t.io.print(String.fromCodePoint(c));
				pend_i+=1;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 3) break;
			if (!is_utf_trail(2)) continue;
			c += pend(2) & ~0xc0;

			if (0xe0 == (pend(0) & 0xf0)) {
				c += (pend(0) & ~0xf0) << 12;
				t.io.print(String.fromCodePoint(c));
				pend_i+=2;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 4) break;
			if (!is_utf_trail(3)) continue;
			c += pend(3) & ~0xc0;

			if (0xf0 == (pend(0) & 0xf8)) {
				c += (pend(0) & ~0xf8) << 18;
				t.io.print(String.fromCodePoint(c));
				pend_i+=3;
				continue;
			}

			t.io.print('?');
		}

		pend_display = pend_display.slice(pend_i);
	}

	function prepare_sock()
	{
		sock = new WebSocket(
			'ws://' + location.host + '/' + location.search);
		sock.onopen = function()
		{
			// Ignore any attempt to clear screen if it's the first
			// message.
			ignore_disp = "\\1b[H\\1b[J";

			if (!pend_send) return;

			sock.send(pend_send);
			pend_send = '';
		};

		sock.onmessage = function(e) { display(e.data); };
	}

	prepare_sock();

	function signal(s)
	{
		if (log_send) {
			console.log('request send: ' + JSON.stringify(s));
			if (log_send > 1) console.trace();
		}

		if (sock.readyState == WebSocket.OPEN) {
			sock.send(pend_send + s);
			pend_send = '';
			return;
		}

		pend_send += s;
		if (sock.readyState > WebSocket.OPEN) prepare_sock();
	}

	t = new hterm.Terminal();
	params = new URLSearchParams(window.location.search);

	termid = params.get('termid');
	pream = params.get('pream');

	cached_title = localStorage['title-' + termid] || '無名';
	if (termid) localStorage['pream-' + termid] = pream || '';

	t.setWindowTitle = function(t)
	{
		if (termid) {
			localStorage['title-' + termid] = t;
			document.title = `[${termid}] ${t}`;
		}
		else
			document.title = t;
	};
	t.setWindowTitle(cached_title);

	function escape(s)
	{
		var e = [], c, ci;

		for (ci = 0; ci < s.length; ci++) {
			c = s.charAt(ci);
			if (c === '\\') e.push('\\\\');
			else if (c === '\n') e.push('\\n');
			else e.push(c);
		}

		return e.join('');
	}

	var open_child_term = function()
	{
		var newid = (termid || '') + '.' + String.fromCharCode(Math.floor(Math.random() * 26) + 'a'.charCodeAt(0));
		window.open(
			'/?termid=' + encodeURIComponent(newid) +
			'&pream=' + encodeURIComponent(pream || ''));
		// return hterm.Keyboard.KeyActions.CANCEL;
	};
	t.onTerminalReady = function()
	{
		io = t.io.push();

		io.sendString = function(s) { signal(escape(s)); };
		io.onVTKeystroke = function(s) { signal(escape(s)); };
		io.onTerminalResize = function(c, r) {
			signal('\\w' + (10000 + r + '').substr(1)
				     + (10000 + c + '').substr(1));
		};

		term_ready = true;
		display('');
		// t.keyboard.keyMap.onCtrlShiftA_ = function(e)
		// {
		// 	return hterm.Keyboard.KeyActions.PASS;
		// };
		// t.keyboard.keyMap.onShiftTab_ = on_shift_tab;

		// This doesn't work in tab apparently:
		// t.passCtrlW = true;

		window.t = t;
	};

	t.decorate(document.querySelector('#terminal'));
	// t.installKeyboard();

	dead_key_hist = ['?', 'x', '?', 'x'];
	function push_dead_key_hist(e)
	{
		switch (e.type) {
		case 'keydown':	dead_key_hist.push('D'); break;
		case 'keyup':	dead_key_hist.push('U'); break;
		default:	dead_key_hist.push('?');
		}

		switch (e.code) {
		case 'ShiftLeft':	dead_key_hist.push('LS'); break;
		case 'ShiftRight':	dead_key_hist.push('RS'); break;
		case 'ControlLeft':	dead_key_hist.push('LC'); break;
		case 'ControlRight':	dead_key_hist.push('RC'); break;
		default:		dead_key_hist.push('?');
		}
	}

	function process_key_down(e)
	{
		var ch, pref;

		if (e.altKey) return false;

		pref = e.metaKey ? '\x1b' : '';

		if (e.shiftKey && e.ctrlKey) {
			switch (e.code) {
			case 'Digit2': signal(pref + '\x00'); return true;
			case 'Digit6': signal(pref + '\x1e'); return true;
			}
			return false;
		}

		if (e.key.length !== 1) {
			if (e.ctrlKey) {
				switch (e.key) {
				case 'Backspace':	/* consume or else it makes a mess */	return true;
				case 'ContextMenu':	signal(pref + '\x1f');			return true;
				default:		return false;
				}
			}

			if (e.shiftKey) {
				if (!pref) {
					// These shortcuts cannot be preceded by Esc as they are not sent to I/O
					switch (e.key) {
					case 'PageDown':	t.scrollPageDown();	return true;
					case 'PageUp':		t.scrollPageUp();	return true;
					case 'Home':		t.scrollHome();		return true;
					case 'End':		t.scrollEnd();		return true;
					}
				}

				switch (e.key) {
				case 'Backspace':	signal(pref + '\x17');		return true;	// C+N
				case 'Enter':		signal(pref + '\x0e');		return true;	// C+W
				case 'Tab':		signal(pref + '\x1b\x5b\x5a');	return true;
				default:						return false;
				}
			}

			switch (e.key) {
			case 'ArrowLeft':	signal(pref + '\x1b\x5b\x44');		return true;
			case 'ArrowUp':		signal(pref + '\x1b\x5b\x41');		return true;
			case 'ArrowRight':	signal(pref + '\x1b\x5b\x43');		return true;
			case 'ArrowDown':	signal(pref + '\x1b\x5b\x42');		return true;
			case 'Enter':		signal(pref + '\r');			return true;
			case 'Backspace':	signal(pref + '\x7f');			return true;
			case 'Escape':		signal(pref + '\x1b');			return true;
			case 'ContextMenu':	signal(pref + '_');			return true;
			case 'Delete':		signal(pref + '\x1b[3~');		return true;
			case 'Tab':		signal(pref + '\t');			return true;
			case 'PageDown':	signal(pref + '\x1b\x5b\x36\x7e');	return true;
			case 'PageUp':		signal(pref + '\x1b\x5b\x35\x7e');	return true;
			case 'Home':		signal(pref + '\x1b\x5b\x48');		return true;
			case 'End':		signal(pref + '\x1b\x5b\x46');		return true;
			case 'Insert':		signal(pref + '\x1b\x5b\x32\x7e');	return true;
			default:							return false;
			}
		}

		if (e.ctrlKey) {
			ch = e.key.charCodeAt(0);
			if (ch >= 0x7b || ch < 0x40) return;
			if (ch >= 0x61) ch -= 0x20;
			ch -= 0x40;

			signal(escape(pref + String.fromCharCode(ch)));
			return true;
		}

		signal(escape(pref + e.key));
		return true;
	}

	// font-family, font-size (height), line-height-padding-size
	var fonts = [
		['jfdot_7x14',		14,	0],
		['ibm_vga_8x16',	16,	2],
		['ibm_vga_9x16',	16,	1],
		['dos_v_ibm_8x19',	20,	1],
	];

	function set_font(ndx)
	{
		t.scrollPort_.screen_.style.fontFamily = fonts[ndx][0];
		t.setFontSize(fonts[ndx][1]);
		t.scrollPort_.lineHeightPaddingSize = fonts[ndx][2];

		t.scrollPort_.syncCharacterSize();
		t.updateCssCharsize_();
		t.syncBoldSafeState();
	};

	fonts.forEach(function(fnt, ndx) {
		var name = fnt[0], sz = fnt[1];
		t.document_.fonts.add(new FontFace(name, 'url(/' + name + '.ttf)'));
		t.document_.fonts.load(`${sz}px ${name}`).then(function()
		{
			if (ndx === 2) set_font(2);
		});
	});

	var macro_map = [
		[['AltLeft', 'KeyI', 'KeyF'], 'git status -s -uno\r'],
		[['AltLeft', 'KeyI', 'ShiftLeft', 'KeyF'], 'git status -s -uall\r'],
		[['AltLeft', 'KeyI', 'KeyD'], 'git diff '],
		[['AltLeft', 'KeyI', 'KeyC', 'KeyO'], 'git checkout '],
		[['AltLeft', 'KeyI', 'KeyC', 'KeyD'], 'git diff --cached '],
		[['AltRight', 'KeyS', 'KeyD'], '\x1b:w\r'],
		[['AltRight', 'KeyS', 'KeyK'], '\x1b:wq\r'],
		[['AltLeft', 'KeyI', 'KeyL'], 'git log --name-status '],
		[['AltLeft', 'KeyI', 'KeyC', 'KeyM'], 'git commit '],
		[['AltLeft', 'Backslash', 'KeyU'], '| grep '],
		[['AltLeft', 'KeyI', 'KeyS'], 'git show '],
		[['AltLeft', 'KeyH', 'KeyT'], open_child_term],
		[['AltLeft', 'Semicolon', 'KeyP'], ':e %:p:h\t'],
		[['AltLeft', 'Semicolon', 'BracketLeft'], ':e \x12%'],
		[['AltRight', 'KeyR', 'KeyS', 'KeyE'], 'sudo shutdown -r now; exit\r'],
		[['AltRight', 'KeyF', 'KeyN', 'KeyA'], set_font.bind(null, 0)],
		[['AltRight', 'KeyF', 'KeyN', 'KeyB'], set_font.bind(null, 1)],
		[['AltRight', 'KeyF', 'KeyN', 'KeyC'], set_font.bind(null, 2)],
		[['AltRight', 'KeyF', 'KeyN', 'KeyD'], set_font.bind(null, 3)],
	];

	t.getScrollPort().getDocument().body.onkeydown = function(e)
	{
		var mi, ki, mch;

		if (e.code === 'AltLeft' || e.code === 'AltRight'
		    || mkeys.length) {
			mkeys.push(e.code);
			e.stopPropagation();
			e.preventDefault();

			for (mi = 0; mi < macro_map.length; mi++) {
				if (macro_map[mi][0].length < mkeys.length) continue;

				for (ki = 0; ki < mkeys.length; ki++) {
					if (mkeys[ki] !== macro_map[mi][0][ki]) break;
				}

				if (ki < mkeys.length) continue;

				if (mkeys.length === macro_map[mi][0].length) {
					// Full match (not just prefix).
					mch = macro_map[mi][1];

					if (typeof mch === 'string')
						signal(escape(mch));
					else if (typeof mch === 'function')
						mch();
					else
						throw 'unknown mapping type: ' + mch;

					mkeys.length = 0;
				}

				return;
			}

			// Neither a full match nor a prefix match.
			signal('?');
			mkeys.length = 0;
			return;
		}

		push_dead_key_hist(e);
		dead_key_hist.splice(0, 2);

		if (!process_key_down(e)) return;
		e.stopPropagation();
		e.preventDefault();
	};

	t.getScrollPort().getDocument().body.onkeyup = function(e)
	{
		var hist;

		if (mkeys.length) return;

		push_dead_key_hist(e);
		hist = dead_key_hist.join('');
		dead_key_hist.splice(0, 2);

		if (hist.endsWith('DLSULS') || hist === 'DLSDRSULS' || hist === 'DLSURSULS') signal(')');
		if (hist.endsWith('DRSURS') || hist === 'DRSULSURS' || hist === 'DRSDLSURS') signal('(');
		if (hist.endsWith('DRCURC')) signal('$');
		if (hist.endsWith('DLCULC')) signal('"');
	};
}

window.onload = function()
{
	lib.init().then(term_init);
};

window.line_indexer = function()
{
	var res = [], curr_rows = [], i, xrow;

	var visible = window.t.getDocument().getElementsByTagName('x-row');
	var sb = window.t.scrollbackRows_;
	var cnt = visible.length + sb.length;

	for (i = 0; i < cnt; i++) {
		xrow = i < sb.length ? sb[i] : visible[i - sb.length];

		curr_rows.push(xrow);

		if (xrow.getAttribute('line-overflow') && i < cnt-1) continue;

		res.push(curr_rows);
		curr_rows = [];
	}

	return {
		'cnt': res.length,
		'at': function(i) {
			if (i < 0 || res >= res.length) return undefined;

			return res[i].map(function(xr) { return xr.innerText; }).join('');
		},
	};
};

// -2: any false
// -1: all false
//  1: all true [default]
//  2: any true
window.notall = -2;
window.none = -1;
window.all = 1;
window.any = 2;

window.array_against_str = function(arr, str)
{
	var i, type, res;

	type = all;
	for (i = 0; i < arr.length; i++) {
		if ('number' === typeof arr[i]) {
			type = arr[i];
			continue;
		}

		res = window.op_against_str(arr[i], str);

		switch (type) {
		case notall:	if (!res)	return true;	else break;
		case none:	if (res)	return false;	else break;
		case all:	if (!res)	return false;	else break;
		case any:	if (res)	return true;	else break;
		}
	}

	return !!(type & 1);
};

window.op_against_str = function(op, str)
{
	if (typeof op === 'function') return op(str);
	if (typeof op === 'string') return str.indexOf(op) >= 0;
	if (op.__proto__ === RegExp.prototype) return op.exec(str);

	if (op.__proto__ == Array.prototype)
		return window.array_against_str(op, str);

	throw 'unknown op type: ' + op;
};

window.f = function(op, around)
{
	var matcher, ndxr, inc, need_sep, i, j, prior_match, match_type, sep;

	inc = {};
	ndxr = window.line_indexer();

	if (around === undefined) {
		around = 0;
		sep = '';
	}
	else
		sep = '----------\n';

	for (i = 0; i < ndxr.cnt; i++) {
		if (!window.op_against_str(op, ndxr.at(i))) continue;

		for (j = i - around; j <= i + around; j++) inc[j] = inc[j] || '-';
		inc[i] = ':';
	}

	out = [];
	need_sep = false;
	prior_match = false;

	for (i = 0; i < ndxr.cnt; i++) {
		match_type = inc[i];
		if (!match_type) {
			need_sep = true;
			continue;
		}

		if (need_sep && prior_match) out.push(sep);
		prior_match = true;
		need_sep = false;

		out.push(i);
		out.push(match_type);
		out.push(ndxr.at(i));
		out.push('\n');
	}

	console.log(out.join(''));
};

window.ar = function(ln, cnt)
{
	var ndxr = window.line_indexer();
	var matched = [], i;

	if (cnt === undefined) cnt = 3;

	for (i = ln - cnt; i <= ln + cnt; i++) {
		matched.push(ndxr.at(i));
		matched.push('\n');
	}

	console.log(matched.join(''));
};

    </script>
  </body>
</html>
