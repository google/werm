<!DOCTYPE html>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<meta charset='utf-8'/>
<html>
  <head>
    <title>werm</title>
<style>

html {
  height: 100%;
}
body {
  position: absolute;
  height: 100%;
  width: 100%;
  overflow: hidden;
  margin: 0px;
  padding: 0px;
}
</style>

  </head>
  <body>
    <div id="terminal"
         style="position:relative; width:100%; height:100%"></div>
    <script>window['extended_macros'] = {}</script>
    <script src="local.js"></script>
    <script src="gum.js"></script>

    <script src="hterm_all.js"></script>
    <script>

var native_to_mn = {
	'Escape':		'es',
	'F1':			'f1',
	'F2':			'f2',
	'F3':			'f3',
	'F4':			'f4',
	'F5':			'f5',
	'F6':			'f6',
	'F7':			'f7',
	'F8':			'f8',
	'F9':			'f9',
	'F10':			'fA',
	'F11':			'fB',
	'F12':			'fC',
	'PrintScreen':		'sr',
	'Pause':		'pa',
	'Enter':		'en',
	'Minus':		'- ',
	'Equal':		'= ',
	'Backspace':		'bs',
	'Tab':			'ta',
	'KeyA':			'A ',
	'KeyB':			'B ',
	'KeyC':			'C ',
	'KeyD':			'D ',
	'KeyE':			'E ',
	'KeyF':			'F ',
	'KeyG':			'G ',
	'KeyH':			'H ',
	'KeyI':			'I ',
	'KeyJ':			'J ',
	'KeyK':			'K ',
	'KeyL':			'L ',
	'KeyM':			'M ',
	'KeyN':			'N ',
	'KeyO':			'O ',
	'KeyP':			'P ',
	'KeyQ':			'Q ',
	'KeyR':			'R ',
	'KeyS':			'S ',
	'KeyT':			'T ',
	'KeyU':			'U ',
	'KeyV':			'V ',
	'KeyW':			'W ',
	'KeyX':			'X ',
	'KeyY':			'Y ',
	'KeyZ':			'Z ',
	'BracketLeft':		'[ ',
	'BracketRight':		'] ',
	'Space':		'sp',
	'AltLeft':		'la',
	'AltRight':		'ra',
	'Digit0':		'0 ',
	'Digit1':		'1 ',
	'Digit2':		'2 ',
	'Digit3':		'3 ',
	'Digit4':		'4 ',
	'Digit5':		'5 ',
	'Digit6':		'6 ',
	'Digit7':		'7 ',
	'Digit8':		'8 ',
	'Digit9':		'9 ',
	'Backslash':		'vs',	// Reverse solidus
	'ShiftLeft':		'ls',
	'ShiftRight':		'rs',
	'CapsLock':		'cl',
	'MetaLeft':		'lw',
	'MetaRight':		'rw',
	'Quote':		'" ',
	'ContextMenu':		'me',
	'ControlLeft':		'lc',
	'ControlRight':		'rc',
	'Comma':		', ',
	'Period':		'. ',
	'Slash':		'/ ',
	'Backquote':		'` ',
	'ScrollLock':		'sl',
	'Home':			'ho',
	'End':			'nd',
	'Delete':		'de',
	'PageUp':		'pu',
	'PageDown':		'pd',
	'Insert':		'in',
	'ArrowUp':		'up',
	'ArrowDown':		'do',
	'ArrowLeft':		'le',
	'ArrowRight':		'ri',
	'NumLock':		'#l',
	'NumpadDivide':		'#/',
	'NumpadSubtract':	'#-',
	'NumpadMultiply':	'#*',
	'NumpadAdd':		'#+',
	'NumpadEnter':		'#e',
	'NumpadDecimal':	'#.',
	'Numpad0':		'#0',
	'Numpad1':		'#1',
	'Numpad2':		'#2',
	'Numpad3':		'#3',
	'Numpad4':		'#4',
	'Numpad5':		'#5',
	'Numpad6':		'#6',
	'Numpad7':		'#7',
	'Numpad8':		'#8',
	'Numpad9':		'#9',
	'Semicolon':		'; ',
	'IntlRo':		'j1',
	'IntlYen':		'j7',
};
 
function cookev(e)
{
	var mn, ce;

	mn = native_to_mn[e.code];
	if (!mn) {
		console.error('no mn available:', e);
		mn = '??';
	}

	ce = {
		mn:		mn,
		type:		e.type,
		key:		e.key,
		ctrlKey:	e.ctrlKey,
		metaKey:	e.metaKey,
		altKey:		e.altKey,
		shiftKey:	e.shiftKey,
	};
	if (log_keys>=2) console.log(ce);
	return ce;
}

var log_send = 0, log_display = 0, log_keys = 0, test = {};

function term_init()
{
	var t, pend_send = '', term_ready = false, sock, pend_display = [],
		pend_escape = '', ignore_disp = '', termid, cached_title, pream,
		params, dead_key_hist, keep_row_ttl, remote_ttl, row_ttl;

	function find_row_ttl()
	{
		var rows, rowi, txt;
		rows = t.document_.getElementsByTagName('x-row');
		rowi = rows.length;
		while (rowi && !txt) txt = rows[--rowi].innerText;
		return txt;
	}

	function set_title()
	{
		var compons, skip_tid;

		compons = [];
		if (termid) compons.push(`[${termid}]`);
		skip_tid = compons.length;
		if (remote_ttl) compons.push(remote_ttl);

		row_ttl = find_row_ttl() || row_ttl;
		if (row_ttl) compons.push('|', row_ttl);

		document.title = compons.join(' ');
		localStorage['title-' + termid] =
			compons.splice(skip_tid).join(' ');
	}

	function print(str)
	{
		t.io.print(str);

		if (keep_row_ttl) return;

		set_title();
		keep_row_ttl = setTimeout(function()
		{
			keep_row_ttl = null;
			set_title();
		}, 2000);
	}

	function display(s)
	{
		var next_esc, pend_i, c;

		function pend(di) { return pend_display[pend_i + di]; }
		function is_utf_trail(di) {
			if (0x80 == (pend(di) & 0xc0)) return true;
			console.warn('not a utf8 trailing byte in print data');
			print('?');
			return false;
		}

		function hex_val(i)
		{
			var c = s.charAt(i);
			if (c >= '0' && c <= '9') return s.charCodeAt(i) - 48;
			if (c >= 'a' && c <= 'f') return s.charCodeAt(i) - 87;
			throw `invalid hex at ${i} in ${s}: ${c}`
		}

		if (ignore_disp === s) s = '';
		ignore_disp = '';

		if (log_display) {
			console.log('display: ' + JSON.stringify(s));
			if (log_display > 1) console.trace();
		}

		if (pend_escape) {
			s = pend_escape + s;
			pend_escape = '';
		}

		while (true) {
			next_esc = s.indexOf('\\');
			if (next_esc === -1) next_esc = s.length;
			if (next_esc > 0) {
				pend_display.push(s.substr(0, next_esc));
				s = s.substr(next_esc);
			}

			if (!s) break;

			if (s.length < 3) {
				// Escape is incomplete, so send it later.
				pend_escape = s;
				break;
			}

			pend_display.push(hex_val(1) * 16 + hex_val(2));

			s = s.substr(3);
		}

		if (!term_ready) return;

		for (pend_i = 0; pend_i < pend_display.length; pend_i++) {
			if (typeof pend(0) === 'string') {
				print(pend(0));
				continue;
			}

			if (pend(0) < 0x80) {
				print(String.fromCharCode(pend(0)));
				continue;
			}

			c = 0;
			if (pend_display.length < 2) break;
			if (!is_utf_trail(1)) continue;
			c += pend(1) & ~0xc0;

			if (0xc0 == (pend(0) & 0xe0)) {
				c += (pend(0) & ~0xe0) << 6;
				print(String.fromCodePoint(c));
				pend_i+=1;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 3) break;
			if (!is_utf_trail(2)) continue;
			c += pend(2) & ~0xc0;

			if (0xe0 == (pend(0) & 0xf0)) {
				c += (pend(0) & ~0xf0) << 12;
				print(String.fromCodePoint(c));
				pend_i+=2;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 4) break;
			if (!is_utf_trail(3)) continue;
			c += pend(3) & ~0xc0;

			if (0xf0 == (pend(0) & 0xf8)) {
				c += (pend(0) & ~0xf8) << 18;
				print(String.fromCodePoint(c));
				pend_i+=3;
				continue;
			}

			console.warn('not a valid utf8 sequence');
			print('?');
		}

		pend_display = pend_display.slice(pend_i);
	}

	function prepare_sock()
	{
		sock = new WebSocket(
			'ws://' + location.host + '/' + location.search);
		sock.onopen = function()
		{
			// Ignore any attempt to clear screen if it's the first
			// message.
			ignore_disp = "\\1b[H\\1b[J";

			if (!pend_send) return;

			sock.send(pend_send);
			pend_send = '';
		};

		sock.onmessage = function(e) { display(e.data); };
	}

	prepare_sock();

	function signal(s)
	{
		if (log_send) {
			console.log('request send: ' + JSON.stringify(s));
			if (log_send > 1) console.trace();
		}

		if (sock.readyState == WebSocket.OPEN) {
			sock.send(pend_send + s);
			pend_send = '';
			return;
		}

		pend_send += s;
		if (sock.readyState > WebSocket.OPEN) prepare_sock();
	}
	function sigapp(p, c)
	{
		var kind = t.keyboard.applicationCursor ? 'O' : '[';
		signal(p + '\x1b' + kind + c);
	}
	function bs_sends()
	{
		return t.keyboard.backspaceSendsBackspace ? '\x08' : '\x7f';
	}

	t = new hterm.Terminal();
	params = new URLSearchParams(window.location.search);

	termid = params.get('termid');
	pream = params.get('pream');

	remote_ttl = localStorage['remote-title-' + termid] || '';
	if (termid) localStorage['pream-' + termid] = pream || '';

	t.setWindowTitle = function(ttl)
	{
		remote_ttl = localStorage['remote-title-' + termid] = ttl;
		set_title();
	};
	t.setWindowTitle(cached_title);

	function escape(s)
	{
		var e = [], c, ci;

		for (ci = 0; ci < s.length; ci++) {
			c = s.charAt(ci);
			if (c === '\\') e.push('\\\\');
			else if (c === '\n') e.push('\\n');
			else e.push(c);
		}

		return e.join('');
	}

	function open_child_term()
	{
		var rand_ltr, newid;

		rand_ltr = String.fromCharCode(97 + 26*Math.random());
		newid = (termid || '') + '.' + rand_ltr;
		window.open(
			'/?termid=' + encodeURIComponent(newid) +
			'&pream=' + encodeURIComponent(pream || ''));
	}

	t.onTerminalReady = function()
	{
		var io = t.io.push();

		io.sendString = function(s) { signal(escape(s)); };
		io.onTerminalResize = function(c, r) {
			signal('\\w' + (10000 + r + '').substr(1)
				     + (10000 + c + '').substr(1));
		};

		term_ready = true;
		display('');

		window.t = t;
	};

	t.decorate(document.querySelector('#terminal'));

	dead_key_hist = ['?', 'x', '?', 'x'];
	function push_dead_key_hist(e)
	{
		switch (e.type) {
		case 'keydown':	dead_key_hist.push('D'); break;
		case 'keyup':	dead_key_hist.push('U'); break;
		default:	dead_key_hist.push('?');
		}

		dead_key_hist.push(e.mn);
	}

	function process_key_down(e)
	{
		var ch, pref;

		if (e.altKey) return false;

		pref = e.metaKey ? '\x1b' : '';

		if (e.shiftKey && e.ctrlKey) {
			switch (e.mn) {
			case '2 ': signal(pref + '\x00'); return true;
			case '6 ': signal(pref + '\x1e'); return true;
			}
			return false;
		}

		if (e.key.length !== 1) {
			if (e.ctrlKey) {
				switch (e.mn) {
				case 'bs':	/* consume or else it makes a mess */	return true;
				case 'me':	signal(pref + '\x1f');			return true;
				default:						return false;
				}
			}

			if (e.shiftKey) {
				if (!pref) {
					// These shortcuts cannot be preceded by Esc as they are not sent to I/O
					switch (e.mn) {
					case 'pd': t.scrollPageDown();	return true;
					case 'pu': t.scrollPageUp();	return true;
					case 'ho': t.scrollHome();	return true;
					case 'nd': t.scrollEnd();	return true;
					}
				}

				switch (e.mn) {
				case 'bs': signal(pref + '\x17');		return true;	// C+N
				case 'en': signal(pref + '\x0e');		return true;	// C+W
				case 'ta': signal(pref + '\x1b\x5b\x5a');	return true;
				default:					return false;
				}
			}

			switch (e.mn) {
			case 'up': sigapp(pref, 'A');		return true;
			case 'do': sigapp(pref, 'B');		return true;
			case 'ri': sigapp(pref, 'C');		return true;
			case 'le': sigapp(pref, 'D');		return true;
			case 'nd': sigapp(pref, 'F');		return true;
			case 'ho': sigapp(pref, 'H');		return true;
			case 'in': signal(pref + '\x1b[2~');	return true;
			case 'de': signal(pref + '\x1b[3~');	return true;
			case 'pu': signal(pref + '\x1b[5~');	return true;
			case 'pd': signal(pref + '\x1b[6~');	return true;
			case 'en': signal(pref + '\r');		return true;
			case 'bs': signal(pref + bs_sends());	return true;
			case 'es': signal(pref + '\x1b');	return true;
			case 'me': signal(pref + '_');		return true;
			case 'ta': signal(pref + '\t');		return true;
			default:				return false;
			}
		}

		if (e.ctrlKey) {
			ch = e.key.charCodeAt(0);
			if (ch >= 0x7b || ch < 0x40) return;
			if (ch >= 0x61) ch -= 0x20;
			ch -= 0x40;

			signal(escape(pref + String.fromCharCode(ch)));
			return true;
		}

		signal(escape(pref + e.key));
		return true;
	}

	// [0] font-family, [1] font-size (height), [2] cell-width,
	// [3] padded-cell-height, [4] allow bold face
	// Small fonts require overriding Chrome's minimum font size setting.
	var fonts = [
		['ibm_ega_8x8',		8,	8,	9,	false],
		['hp_100lx_10x11',	12,	10,	13,	false],
		['jfdot_7x14',		14,	7,	14,	true],
		['ibm_vga_8x16',	16,	8,	17,	false],
		['ibm_vga_9x16',	16,	9,	17,	false],
		['dos_v_ibm_8x19',	20,	8,	19,	false],
		['cl_stringray_8x19',	20,	8,	19,	false],
		['ibm_xga_ai_12x23',	24,	12,	23,	false],
		['dos_v_re_12x30',	32,	12,	28,	true],
	];

	function set_font(ndx)
	{
		var f = fonts[ndx];

		t.scrollPort_.screen_.style.fontFamily = f[0];
		t.setFontSize(f[1]);

		t.scrollPort_.characterSize = {width: f[2], height: f[3]};
		t.scrollPort_.resize();
		t.updateCssCharsize_();

		function bolden(scr) { scr.textAttributes.enableBold = f[4]; }
		bolden(t.primaryScreen_);
		bolden(t.alternateScreen_);
	};

	fonts.forEach(function(fnt, ndx) {
		var name = fnt[0], sz = fnt[1];
		t.document_.fonts.add(new FontFace(name, `url(/${name}.ttf)`));
		t.document_.fonts.load(`${sz}px ${name}`).then(function()
		{
			if (ndx === 4) set_font(4);
		});
	});

	var font_key;
	function set_font_key(key)
	{
		if (!/^Key.$/.test(key)) return false;

		font_key = key.charCodeAt(3) - 65;
		return font_key >= 0 && font_key < fonts.length;
	}
	function set_font_macro() { set_font(font_key); }

	var repeat_cnt, repeater, repeat_boxes = [];
	const REPEAT_BOX_CNT = 8;
	function make_repeat_box(layer)
	{
		var box;

		if (repeat_boxes[layer]) return;
		repeat_boxes[layer] = box = t.document_.createElement('div');

		box.style.position = 'absolute';
		box.style.opacity = 0.5;
		box.style.borderColor = `hsl(
			${layer*5%REPEAT_BOX_CNT/REPEAT_BOX_CNT * 360},
			90%, 50%)`
		box.style.borderStyle = 'solid';
		box.style.borderBottomWidth = box.style.borderTopWidth = 
			t.cursorNode_.style.height;
		box.style.borderLeftWidth = box.style.borderRightWidth = 
			t.cursorNode_.style.width;

		layer++;
		box.style.left = `calc(
			var(--hterm-curs-left)
			- ${layer*5} * var(--hterm-charsize-width)
		)`;

		box.style.width = `calc(
			${layer*10 - 1} * var(--hterm-charsize-width)
		)`;

		box.style.top = `calc(
			var(--hterm-curs-top)
			- ${layer*5} * var(--hterm-charsize-height)
		)`;
		box.style.height = `calc(
			${layer*10 - 1} * var(--hterm-charsize-height)
		)`;

		t.scrollPort_.screen_.appendChild(box);
	}

	function set_repeat_key(code)
	{
		var boxi, box;

		switch (code) {
		case 'bs': repeater = [0, bs_sends()];	break;
		case 'vs': repeater = [0, '\x1b[3~'];	break;
		case 'en': repeater = [0, '\r'];	break;
		case 'ri': repeater = [1, 'C'];		break;
		case 'le': repeater = [1, 'D'];		break;
		case 'up': repeater = [1, 'A'];		break;
		case 'do': repeater = [1, 'B'];		break;

		default:	return false;
		}

		for (boxi = 0; boxi < REPEAT_BOX_CNT; boxi++) {
			make_repeat_box(boxi);
			repeat_boxes[boxi].style.visibility = 'visible';
		}

		return true;
	}

	function set_repeat_cnt(code)
	{
		var boxi;

		for (boxi = 0; boxi < repeat_boxes.length; boxi++)
			repeat_boxes[boxi].style.visibility = 'hidden';

		switch (code) {
		case 'ra': repeat_cnt = 0;	return true;
		case 'rs': repeat_cnt = 40;	return true;
		}

		if (code.charAt(1) != ' ') return false;

		repeat_cnt =
			//000000000111111111122222222223333333
			//123456789012345678901234567890123456789
			' 12345QWERTASDFGZXCVB7890-UIOP[JKL;"M,./'
			.indexOf(code.charAt(0));
		return repeat_cnt >= 1;
	}

	function repeat_keystroke() {
		while (repeat_cnt--) {
			if (!repeater[0])
				signal(repeater[1]);
			else
				sigapp('', repeater[1]);
		}
	}

	var barrier_dig = [], barrier_div;
	function set_barrier_dig(code)
	{
		barrier_dig[this] = code[1];
		return /#[0-9]/.test(code);
	}
	function show_barrier()
	{
		var col, s;

		if (barrier_div) t.scrollPort_.screen_.removeChild(barrier_div);
		barrier_div = null;

		col = Number(barrier_dig.join(''));
		if (!col) return;

		barrier_div = t.document_.createElement('div');
		s = barrier_div.style;
		s.position = 'absolute';
		s.opacity = 0.3;
		s.backgroundColor = 'hsl(' + (col * 283 % 360) + ', 90%, 50%)'
		s.left = `calc(
			var(--hterm-charsize-width) * ${col}
			+ var(--hterm-screen-padding-size)
		)`;
		s.width = 'var(--hterm-charsize-width)'
		s.top = '0';
		s.height = '100%';
		t.scrollPort_.screen_.appendChild(barrier_div);
	}

	var macro_map = [
		[['la', 'I ', 'F '], 'git status -s -uno\r'],
		[['la', 'I ', 'ls', 'F '], 'git status -s -uall\r'],
		[['la', 'I ', 'D '], 'git diff '],
		[['la', 'I ', 'C ', 'O '], 'git checkout '],
		[['la', 'I ', 'C ', 'D '], 'git diff --cached '],
		[['ra', 'S ', 'D '], '\x1b:w\r'],
		[['ra', 'S ', 'K '], '\x1b:wq\r'],
		[['la', 'I ', 'L '], 'git log --name-status '],
		[['la', 'I ', 'B ', 'R '], 'git branch '],
		[['la', 'I ', 'C ', 'M '], 'git commit '],
		[['la', 'I ', 'P ', 'S '], 'git push '],
		[['la', 'I ', 'P ', 'L '], 'git pull '],
		[['la', 'vs', 'U '], '| grep '],
		[['ra', 'D ', 'G '], 'grep -Irn '],
		[['la', 'I ', 'S '], 'git show '],
		[['la', 'H ', 'T '], open_child_term],
		[['la', '; ', 'P '], ':e %:p:h\t'],
		[['la', '; ', '[ '], ':e \x12%'],
		[['ra', 'R ', 'S ', 'E '], 'sudo shutdown -r now; exit\r'],
		[['ra', 'F ', 'N ', set_font_key], set_font_macro],
		[['ra', 'ls', 'E '], '\x1bA'],
		[['ra', 'ls', 'I '], '\x1bI'],

		[['ra', set_repeat_key, set_repeat_cnt], repeat_keystroke],
		[['la',
		 set_barrier_dig.bind(0),
		 set_barrier_dig.bind(1),
		 set_barrier_dig.bind(2)], show_barrier],
	];

	function collect_macros(name)
	{
		var map = window.extended_macros[name] || [];
		while (map.length) macro_map.push(map.pop());
	}

	collect_macros('gum');
	collect_macros('local');

	var mkeys = [], got_key_up = false;

	function process_mkey(e)
	{
		var mi, ki, mch, mk;

		if (!mkeys.length) {
			if (e.mn != 'la' && e.mn != 'ra') return false;
			got_key_up = false;
		}
		else if (!got_key_up && !e.altKey) {
			// We never received Alt release event, but the current
			// event doesn't have the altKey bit set.
			// Chrome may have hid the event from us, indicating an
			// Ash shortcut was activated, so we don't consider
			// macros.
			mkeys.length = 0;
			return false;
		}

		mkeys.push(e.mn);

		for (mi = 0; mi < macro_map.length; mi++) {
			if (macro_map[mi][0].length < mkeys.length) continue;

			for (ki = 0; ki < mkeys.length; ki++) {
				mk = macro_map[mi][0][ki];
				if (typeof mk === 'string') {
					if (mkeys[ki] !== mk) break;
				}
				else if (typeof mk === 'function') {
					if (!mk(mkeys[ki])) break;
				}
				else {
					console.log(mi, macro_map[mi], ki, mk);
					throw 'invalid macro key';
				}
			}

			if (ki < mkeys.length) continue;

			if (mkeys.length === macro_map[mi][0].length) {
				// Full match (not just prefix).
				mch = macro_map[mi][1];

				if (typeof mch === 'string')
					signal(escape(mch));
				else if (typeof mch === 'function')
					mch();
				else
					throw 'unknown mapping type: ' + mch;

				mkeys.length = 0;
			}

			return true;
		}

		// Neither a full match nor a prefix match.
		console.warn('no matching macro');
		signal('?');
		mkeys.length = 0;
		return true;
	}

	t.getScrollPort().getDocument().body.onkeydown = function(e)
	{
		var ce;

		if (log_keys) console.log('scrollport key:', e);

		ce = cookev(e);
		if (!process_mkey(ce)) {
			push_dead_key_hist(ce);
			dead_key_hist.splice(0, 2);

			if (!process_key_down(ce)) return;
		}
		e.stopPropagation();
		e.preventDefault();
	};

	t.getScrollPort().getDocument().body.onkeyup = function(e)
	{
		var hist;

		if (log_keys) console.log('scrollport key:', e);

		if (mkeys.length) {
			got_key_up = true;
			return;
		}

		e = cookev(e);
		push_dead_key_hist(e);
		hist = dead_key_hist.join('');
		dead_key_hist.splice(0, 2);

		if (hist.endsWith('DlsUls') || hist === 'DlsDrsUls' || hist === 'DlsUrsUls') signal(')');
		if (hist.endsWith('DrsUrs') || hist === 'DrsUlsUrs' || hist === 'DrsDlsUrs') signal('(');
		if (hist.endsWith('DrcUrc')) signal('$');
		if (hist.endsWith('DlcUlc')) signal('"');
	};
}

window.onload = function()
{
	lib.init().then(term_init);
};

window.line_indexer = function()
{
	var res = [], curr_rows = [], i, xrow;

	var visible = window.t.getDocument().getElementsByTagName('x-row');
	var sb = window.t.scrollbackRows_;
	var cnt = visible.length + sb.length;

	for (i = 0; i < cnt; i++) {
		xrow = i < sb.length ? sb[i] : visible[i - sb.length];

		curr_rows.push(xrow);

		if (xrow.getAttribute('line-overflow') && i < cnt-1) continue;

		res.push(curr_rows);
		curr_rows = [];
	}

	return {
		'cnt': res.length,
		'at': function(i) {
			if (i < 0 || res >= res.length) return undefined;

			return res[i].map(function(xr) { return xr.innerText; }).join('');
		},
	};
};

// -2: any false
// -1: all false
//  1: all true [default]
//  2: any true
window.notall = -2;
window.none = -1;
window.all = 1;
window.any = 2;

window.array_against_str = function(arr, str)
{
	var i, type, res;

	type = all;
	for (i = 0; i < arr.length; i++) {
		if ('number' === typeof arr[i]) {
			type = arr[i];
			continue;
		}

		res = window.op_against_str(arr[i], str);

		switch (type) {
		case notall:	if (!res)	return true;	else break;
		case none:	if (res)	return false;	else break;
		case all:	if (!res)	return false;	else break;
		case any:	if (res)	return true;	else break;
		}
	}

	return !!(type & 1);
};

window.op_against_str = function(op, str)
{
	if (typeof op === 'function') return op(str);
	if (typeof op === 'string') return str.indexOf(op) >= 0;
	if (op.__proto__ === RegExp.prototype) return op.exec(str);

	if (op.__proto__ == Array.prototype)
		return window.array_against_str(op, str);

	throw 'unknown op type: ' + op;
};

window.f = function(op, around)
{
	var matcher, ndxr, inc, need_sep, i, j, prior_match, match_type, sep;

	inc = {};
	ndxr = window.line_indexer();

	if (around === undefined) {
		around = 0;
		sep = '';
	}
	else
		sep = '----------\n';

	for (i = 0; i < ndxr.cnt; i++) {
		if (!window.op_against_str(op, ndxr.at(i))) continue;

		for (j = i - around; j <= i + around; j++) inc[j] = inc[j] || '-';
		inc[i] = ':';
	}

	out = [];
	need_sep = false;
	prior_match = false;

	for (i = 0; i < ndxr.cnt; i++) {
		match_type = inc[i];
		if (!match_type) {
			need_sep = true;
			continue;
		}

		if (need_sep && prior_match) out.push(sep);
		prior_match = true;
		need_sep = false;

		out.push(i);
		out.push(match_type);
		out.push(ndxr.at(i));
		out.push('\n');
	}

	console.log(out.join(''));
};

window.ar = function(ln, cnt)
{
	var ndxr = window.line_indexer();
	var matched = [], i;

	if (cnt === undefined) cnt = 3;

	for (i = ln - cnt; i <= ln + cnt; i++) {
		matched.push(ndxr.at(i));
		matched.push('\n');
	}

	console.log(matched.join(''));
};

    </script>
  </body>
</html>
