<!DOCTYPE html>
<meta charset='utf-8'/>
<html>
  <head>
    <title>werm</title>
<style>

@font-face {
  font-family: jfdot;
  src: url(font.ttf);
}

html {
  height: 100%;
}
body {
  position: absolute;
  height: 100%;
  width: 100%;
  overflow: hidden;
  margin: 0px;
  padding: 0px;
}
</style>

  </head>
  <body>
    <div id="terminal"
         style="position:relative; width:100%; height:100%"></div>
    <script src="hterm_all.js"></script>
    <script>

var log_send = 0, log_display = 0;

function term_init()
{
	var t, io, pend_send = '', term_ready = false, sock, pend_display = [],
		pend_escape = '', ignore_disp = '';

	function display(s)
	{
		var next_esc, pend_i, c;

		function pend(di) { return pend_display[pend_i + di]; }
		function is_utf_trail(di) {
			if (0x80 == (pend(di) & 0xc0)) return true;
			t.io.print('?');
			return false;
		}

		function hex_val(i)
		{
			var c = s.charAt(i);
			if (c >= '0' && c <= '9') return s.charCodeAt(i) - 48;
			if (c >= 'a' && c <= 'f') return s.charCodeAt(i) - 87;
			throw `invalid hex at ${i} in ${s}: ${c}`
		}

		if (ignore_disp === s) s = '';
		ignore_disp = '';

		if (log_display) {
			console.log('display: ' + JSON.stringify(s));
			if (log_display > 1) console.trace();
		}

		if (pend_escape) {
			s = pend_escape + s;
			pend_escape = '';
		}

		while (true) {
			next_esc = s.indexOf('\\');
			if (next_esc === -1) next_esc = s.length;
			if (next_esc > 0) {
				pend_display.push(s.substr(0, next_esc));
				s = s.substr(next_esc);
			}

			if (!s) break;

			if (s.length < 3) {
				// Escape is incomplete, so send it later.
				pend_escape = s;
				break;
			}

			pend_display.push(hex_val(1) * 16 + hex_val(2));

			s = s.substr(3);
		}

		if (!term_ready) return;

		for (pend_i = 0; pend_i < pend_display.length; pend_i++) {
			if (typeof pend(0) === 'string') {
				t.io.print(pend(0));
				continue;
			}

			if (pend(0) < 0x80) {
				t.io.print(String.fromCharCode(pend(0)));
				continue;
			}

			c = 0;
			if (pend_display.length < 2) break;
			if (!is_utf_trail(1)) continue;
			c += pend(1) & ~0xc0;

			if (0xc0 == (pend(0) & 0xe0)) {
				c += (pend(0) & ~0xe0) << 6;
				t.io.print(String.fromCodePoint(c));
				pend_i+=1;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 3) break;
			if (!is_utf_trail(2)) continue;
			c += pend(2) & ~0xc0;

			if (0xe0 == (pend(0) & 0xf0)) {
				c += (pend(0) & ~0xf0) << 12;
				t.io.print(String.fromCodePoint(c));
				pend_i+=2;
				continue;
			}

			c <<= 6;
			if (pend_display.length < 4) break;
			if (!is_utf_trail(3)) continue;
			c += pend(3) & ~0xc0;

			if (0xf0 == (pend(0) & 0xf8)) {
				c += (pend(0) & ~0xf8) << 18;
				t.io.print(String.fromCodePoint(c));
				pend_i+=3;
				continue;
			}

			t.io.print('?');
		}

		pend_display = pend_display.slice(pend_i);
	}

	function prepare_sock()
	{
		sock = new WebSocket(
			'ws://' + location.host + '/' + location.search);
		sock.onopen = function()
		{
			// Ignore any attempt to clear screen if it's the first
			// message.
			ignore_disp = "\\1b[H\\1b[J";

			if (!pend_send) return;

			sock.send(pend_send);
			pend_send = '';
		};

		sock.onmessage = function(e) { display(e.data); };
	}

	prepare_sock();

	function signal(s)
	{
		if (log_send) {
			console.log('request send: ' + JSON.stringify(s));
			if (log_send > 1) console.trace();
		}

		if (sock.readyState == WebSocket.OPEN) {
			sock.send(pend_send + s);
			pend_send = '';
			return;
		}

		pend_send += s;
		if (sock.readyState > WebSocket.OPEN) prepare_sock();
	}

	t = new hterm.Terminal();
	t.setWindowTitle = function(t)
	{
		var termid = (new URLSearchParams(window.location.search)).get('termid');
		if (termid)
			document.title = `[${termid}] ${t}`
		else
			document.title = t;
	};

	function escape(s)
	{
		var e = [], c, ci;

		for (ci = 0; ci < s.length; ci++) {
			c = s.charAt(ci);
			if (c === '\\') e.push('\\\\');
			else if (c === '\n') e.push('\\n');
			else e.push(c);
		}

		return e.join('');
	}

	t.onTerminalReady = function()
	{
		io = t.io.push();

		io.sendString = function(s) { signal(escape(s)); };
		io.onVTKeystroke = function(s) { signal(escape(s)); };
		io.onTerminalResize = function(c, r) {
			signal('\\w' + (10000 + r + '').substr(1)
				     + (10000 + c + '').substr(1));
		};

		term_ready = true;
		display('');
		t.keyboard.altGrMode = 'none';
		t.keyboard.keyMap.onCtrlShiftA_ = function(e)
		{
			return hterm.Keyboard.KeyActions.PASS;
		};
	};

	t.decorate(document.querySelector('#terminal'));
	t.installKeyboard();
}

window.onload = function()
{
	lib.init().then(term_init);
};
    </script>
  </body>
</html>
