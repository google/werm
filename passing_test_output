WRITE_TO_SUBPROC_CORE
should ignore newline:
kbd[hello ho]
kbd[w are yo]
kbd[u]
empty string:
no-op escape \N:
change window size after \N:
sigwin r=99 c=11
missing newline:
kbd[asdf]
sending sigwinch:
kbd[about to]
kbd[ resize.]
kbd[.....all]
kbd[ done]
sigwin r=91 c=42
escape seqs:
kbd[line one]
kbd[\012line tw]
kbd[o\012line 3]
kbd[ \134 (reve]
kbd[rse soli]
kbd[dus)\012]
escape seqs straddling:
kbd[line one]
kbd[\012line tw]
kbd[o]
kbd[\012line 3 ]
kbd[\134 (rever]
kbd[se solid]
kbd[us)\012]
sigwin r=120 c=140
TEE_TTY_CONTENT
pending line
hello
finished line
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx[exceeded]
abcxyz
abcdef
move back x2 and delete to eol
abcd
move back x1 and insert
asdxy
move back and forward
asdf
move back x2 and forward x1, then del to EOL
asd
as above, but in separate calls
asd
move left x3, move right x2, del EOL; 'right' seq in sep calls
123 UI
drop console title escape seq
abcxyz
abcxyz
123456
drop console title escape seq; separate calls
abcxyz
bracketed paste mode
hello) after
before (hello) after
drop color and font
before : after
before : after
before : After
first ;; second
\r to move to start of line
XYZ123
something makes the logs stop
[0]~$ seq 1 | less
[0]~$ # asdf
\r then delete line
foo
arrow keys are translated to escape sequences
app cursor off: up,down,right,left=ESC [ A,B,C,D
kbd[left (\033[]
kbd[D \033[D)\015]
kbd[up down ]
kbd[up (\033[A ]
kbd[\033[B \033[A)]
kbd[\015]
kbd[right (\033]
kbd[[C)\015]
app cursor on: same codes as when off but O instead of [
kbd[left (\033O]
kbd[D \033OD)\015]
kbd[up down ]
kbd[up (\033OA ]
kbd[\033OB \033OA)]
kbd[\015]
kbd[right (\033]
kbd[OC)\015]
bad input tolerance: terminate OS cmd without char 7
don't hide me
backward to negative linepos, then dump line to log
x
escape before sending to attached clients
abcd\0d\0a
xyz\08\09\0d\0a
pass OS escape to client
\1b]0;asdf\07xyz\0d\0a
simplify alternate mode signal
\1b[?47\s2hhello\0d\0a\1b[?47\s1l
\1b[
?47\s2hhello\0d\0a\1b
[?47\s1l
\1b[?1047\s2hhello\0d\0a\1b[?1047\s1l
regression
\1b[?2004h\1b]0;matvore@penguin: ~\07\1b[01;32mmatvore@penguin\1b[00m:\1b[01;34m~\1b[00m$ \0d\1b[K\1b]0;matvore@penguin: ~\07\1b[01;32mmatvore@penguin\1b[00m:\1b[01;34m~\1b[00m$ 
passthrough escape \033[1P from subproc to client
\1b[1P
\1b[4P
\1b[5P
\1b[16P
delete 5 characters ahead
$ sdfasdf # asdfasdfasdf
delete 12 characters ahead
$  # asdfasdfasdf
delete 16 characters ahead
$ sdfasdfasdf
save rawout from before OS escape
abc\1b]0;new-t
<between calls>
itle\07xyz\0d\0a
1049h/l code for switching to/from alternate screen + other ops
abc \1b[?1049\ss\s2\clh
-in-\1b[?1049\s1\rslout
dump of state
\s1
\1b[?47\s2h
\s2
\s2
\1b[?47\s1l
\s1
\1b[?1049\ss\s2\clh
\s2
\1b[?1049\s1\rsl
\s1
do not save bell character in plain text log
ready... D I N G!
editing a long line
sigwin r=30 c=104
cd platform2
[0]platform2$ git log --graph --format="%ct %h %s" |perl -pE'/^(.*[^0-9])?(\d{8,10})\b(.*)/ and $_=$1.`d\n//'|less 
editing a long line in a narrower window
sigwin r=80 c=61
matvore@penguin:~$ echo a --------------------------------------------------------------------------------
go up more rows than exist in the linebuf
sigwin r=80 c=60
set long then shorter title
\@title:longtitle
\@title:1+1++1
title in recounted state
\@title:sometitle
  recount: \s1\@title:sometitle
... continued: unset title, respond with empty title
kbd[thisisno]
kbd[rmalkeyb]
kbd[input]
\@title:
  recount (should not include title here): \s1
title is too long
rout buffer: this is plain terminal text
\@title:abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab
log: this is plain terminal text
stored title length: 128
do not include altscreen content in scrollback log
xyz
abcrest
move to col
] 
cts-tf > run cts -m CtsInitTestCases -t keychords#init_inotify
move to col 2
axyz
shift rest of line then overwrite
xyz234
shift remaining characters right
xyz       asdf
shift remaining characters right more
xyz 
xyz            asdf
:)xyz  ..more
:)xyzmore
12345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345612345..more:)  6123456123456123456123456123456123456123456123456
move more characters right than are in the line
!!!!                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    abcd
!!!!                                              abcd
make long line too big to fit into buffer
!!!                             *******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
access obj with bad ID
[binary_name]: bad id: -2
valid use of new obj, then access invalid fld
[binary_name]: fld 6 out of range for obj -1
0,0,0,0,0,42,99,100,-5,1048575,
multiple IDs
allocate 100 fresh id's
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
re-use 3 and allocate 7 fresh id's
42,75,50,100,101,102,103,104,105,106,
freed an ID, now use it [crash]
[binary_name]: unallocated id: -42
dequeue test
pop only value: 42
is empty, so should have 0, 0: 0, 0
pop one of two values: 44
about to pop 21 values to make it empty again
46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,
push 100 values onto freshly-made dequeue
9,10,13,18,25,34,45,58,73,90,109,130,153,178,205,234,265,298,333,370,409,450,493,538,585,634,685,738,793,850,909,970,1033,1098,1165,1234,1305,1378,1453,1530,1609,1690,1773,1858,1945,2034,2125,2218,2313,2410,2509,2610,2713,2818,2925,3034,3145,3258,3373,3490,3609,3730,3853,3978,4105,4234,4365,4498,4633,4770,4909,5050,5193,5338,5485,5634,5785,5938,6093,6250,6409,6570,6733,6898,7065,7234,7405,7578,7753,7930,8109,8290,8473,8658,8845,9034,9225,9418,9613,9810,
about to pop one too many
[binary_name]: dequeue -1 is already empty; cannot pop
