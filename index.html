<!DOCTYPE html>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<meta charset='utf-8'/>
<html>
  <head>
    <title>werm</title>
<style>

html {
  height: 100%;
}
body {
  position: absolute;
  height: 100%;
  width: 100%;
  overflow: hidden;
  margin: 0px;
  padding: 0px;
}
</style>

  </head>
  <body>
    <div id="terminal"
         style="position:relative; width:100%; height:100%"></div>
    <script>window['extended_macros'] = {}</script>

    <script src="extra.js"></script>

    <script src="third_party/hterm_all.js"></script>
    <script>

var native_to_mn = {
	'Escape':		'es',
	'F1':			'f1',
	'F2':			'f2',
	'F3':			'f3',
	'F4':			'f4',
	'F5':			'f5',
	'F6':			'f6',
	'F7':			'f7',
	'F8':			'f8',
	'F9':			'f9',
	'F10':			'fA',
	'F11':			'fB',
	'F12':			'fC',
	'PrintScreen':		'sr',
	'Pause':		'pa',
	'Enter':		'en',
	'Minus':		'- ',
	'Equal':		'= ',
	'Backspace':		'bs',
	'Tab':			'ta',
	'KeyA':			'A ',
	'KeyB':			'B ',
	'KeyC':			'C ',
	'KeyD':			'D ',
	'KeyE':			'E ',
	'KeyF':			'F ',
	'KeyG':			'G ',
	'KeyH':			'H ',
	'KeyI':			'I ',
	'KeyJ':			'J ',
	'KeyK':			'K ',
	'KeyL':			'L ',
	'KeyM':			'M ',
	'KeyN':			'N ',
	'KeyO':			'O ',
	'KeyP':			'P ',
	'KeyQ':			'Q ',
	'KeyR':			'R ',
	'KeyS':			'S ',
	'KeyT':			'T ',
	'KeyU':			'U ',
	'KeyV':			'V ',
	'KeyW':			'W ',
	'KeyX':			'X ',
	'KeyY':			'Y ',
	'KeyZ':			'Z ',
	'BracketLeft':		'[ ',
	'BracketRight':		'] ',
	'Space':		'sp',
	'AltLeft':		'la',
	'AltRight':		'ra',
	'Digit0':		'0 ',
	'Digit1':		'1 ',
	'Digit2':		'2 ',
	'Digit3':		'3 ',
	'Digit4':		'4 ',
	'Digit5':		'5 ',
	'Digit6':		'6 ',
	'Digit7':		'7 ',
	'Digit8':		'8 ',
	'Digit9':		'9 ',
	'Backslash':		'vs',	// Reverse solidus
	'ShiftLeft':		'ls',
	'ShiftRight':		'rs',
	'CapsLock':		'cl',
	'MetaLeft':		'lw',
	'MetaRight':		'rw',
	'Quote':		'" ',
	'ContextMenu':		'me',
	'ControlLeft':		'lc',
	'ControlRight':		'rc',
	'Comma':		', ',
	'Period':		'. ',
	'Slash':		'/ ',
	'Backquote':		'` ',
	'ScrollLock':		'sl',
	'Home':			'ho',
	'End':			'nd',
	'Delete':		'de',
	'PageUp':		'pu',
	'PageDown':		'pd',
	'Insert':		'in',
	'ArrowUp':		'up',
	'ArrowDown':		'do',
	'ArrowLeft':		'le',
	'ArrowRight':		'ri',
	'NumLock':		'#l',
	'NumpadDivide':		'#/',
	'NumpadSubtract':	'#-',
	'NumpadMultiply':	'#*',
	'NumpadAdd':		'#+',
	'NumpadEnter':		'#e',
	'NumpadDecimal':	'#.',
	'Numpad0':		'#0',
	'Numpad1':		'#1',
	'Numpad2':		'#2',
	'Numpad3':		'#3',
	'Numpad4':		'#4',
	'Numpad5':		'#5',
	'Numpad6':		'#6',
	'Numpad7':		'#7',
	'Numpad8':		'#8',
	'Numpad9':		'#9',
	'Semicolon':		'; ',
	'IntlRo':		'j1',
	'IntlYen':		'j7',
};
 
function sanit(s)
{
	var e = [], c, ci;

	for (ci = 0; ci < s.length; ci++) {
		c = s.charAt(ci);
		if (c === '\\') e.push('\\\\');
		else if (c === '\n') e.push('\\n');
		else e.push(c);
	}

	return e.join('');
}

function cookev(e)
{
	var mn, ce;

	mn = native_to_mn[e.code];
	if (!mn) {
		console.error('no mn available');
		console.log(e);
		mn = '??';
	}

	ce = {
		mn:		mn,
		type:		e.type,
		key:		e.key,
		ctrlKey:	e.ctrlKey,
		metaKey:	e.metaKey,
		altKey:		e.altKey,
		shiftKey:	e.shiftKey,
	};
	if (log_mn) console.log(ce);
	return ce;
}

var log_matching = 0, log_send = 0, log_display = 0, log_keys = 0, test = {},
	log_mn, log_print, log_macks;

function term_init()
{
	var t, pend_send = '', term_ready = false, sock, pend_display = [],
		pend_escape = '', ignore_disp = '', termid, cached_title, pream,
		params, dead_key_hist, keep_row_ttl, row_ttl, locked_ttl, host;

	function find_row_ttl()
	{
		var rows, rowi, txt;
		rows = t.document_.getElementsByTagName('x-row');
		rowi = rows.length;
		while (rowi && !txt) txt = rows[--rowi].innerText;
		return txt;
	}

	host = location.host.replace(/^localhost:/, ':');

	function set_locked_title()
	{
		var ttl;

		ttl = find_row_ttl();
		if (!ttl) return;

		locked_ttl = 1;
		localStorage['locktitle-' + termid] = 1;
		row_ttl = ttl;
		set_title();
	}

	function unlock_title()
	{
		locked_ttl = localStorage['locktitle-' + termid] = 0;
		set_title();
	}

	function set_title()
	{
		var compons;

		compons = [];
		if (termid) compons.push(`[${termid}]`);

		if (!locked_ttl) row_ttl = find_row_ttl() || row_ttl;

		if (row_ttl) compons.push(row_ttl);
		compons.push(host);

		document.title = compons.join(' | ');
		if (row_ttl) localStorage['title-' + termid] = row_ttl;
	}

	function print(str)
	{
		if (log_print) console.log('print:', encodeURI(str));
		t.io.print(str);

		if (locked_ttl || keep_row_ttl) return;

		set_title();
		keep_row_ttl = setTimeout(function()
		{
			keep_row_ttl = null;
			set_title();
		}, 2000);
	}

	function display(s)
	{
		var next_esc, pend_i, c, pend_remain;

		function pend(di) { return pend_display[pend_i + di]; }
		function is_utf_trail(di) {
			if (0x80 == (pend(di) & 0xc0)) return true;
			console.warn('not a utf8 trailing byte in print data');
			print('?');
			return false;
		}

		function hex_val(i)
		{
			var c = s.charAt(i);
			if (c >= '0' && c <= '9') return s.charCodeAt(i) - 48;
			if (c >= 'a' && c <= 'f') return s.charCodeAt(i) - 87;
			throw `invalid hex at ${i} in ${s}: ${c}`
		}

		if (ignore_disp === s) s = '';
		ignore_disp = '';

		if (log_display) {
			console.log('display:', encodeURI(s));
			if (log_display > 1) console.trace();
		}

		if (pend_escape) {
			s = pend_escape + s;
			pend_escape = '';
		}

		while (true) {
			next_esc = s.indexOf('\\');
			if (next_esc === -1) next_esc = s.length;
			if (next_esc > 0) {
				pend_display.push(s.substr(0, next_esc));
				s = s.substr(next_esc);
			}

			if (!s) break;

			if (s.length < 3) {
				// Escape is incomplete, so send it later.
				pend_escape = s;
				break;
			}

			if (s.startsWith('\\s1'))
				t.setAlternateMode(false);
			else if (s.startsWith('\\s2'))
				t.setAlternateMode(true);
			else if (s.startsWith('\\ss'))
				t.saveCursorAndState();
			else if (s.startsWith('\\cl'))
				t.clear();
			else if (s.startsWith('\\rs'))
				t.restoreCursorAndState();
			else
				pend_display.push(hex_val(1) * 16 + hex_val(2));

			s = s.substr(3);
		}

		if (!term_ready) return;

		for (pend_i = 0; pend_i < pend_display.length; pend_i++) {
			if (typeof pend(0) === 'string') {
				print(pend(0));
				continue;
			}

			if (pend(0) < 0x80) {
				print(String.fromCharCode(pend(0)));
				continue;
			}

			c = 0;
			pend_remain = pend_display.length - pend_i;
			if (pend_remain < 2) break;
			if (!is_utf_trail(1)) continue;
			c += pend(1) & ~0xc0;

			if (0xc0 == (pend(0) & 0xe0)) {
				c += (pend(0) & ~0xe0) << 6;
				print(String.fromCodePoint(c));
				pend_i+=1;
				continue;
			}

			c <<= 6;
			if (pend_remain < 3) break;
			if (!is_utf_trail(2)) continue;
			c += pend(2) & ~0xc0;

			if (0xe0 == (pend(0) & 0xf0)) {
				c += (pend(0) & ~0xf0) << 12;
				print(String.fromCodePoint(c));
				pend_i+=2;
				continue;
			}

			c <<= 6;
			if (pend_remain < 4) break;
			if (!is_utf_trail(3)) continue;
			c += pend(3) & ~0xc0;

			if (0xf0 == (pend(0) & 0xf8)) {
				c += (pend(0) & ~0xf8) << 18;
				print(String.fromCodePoint(c));
				pend_i+=3;
				continue;
			}

			console.warn('not a valid utf8 sequence');
			print('?');
		}

		pend_display = pend_display.slice(pend_i);
	}

	function prepare_sock()
	{
		sock = new WebSocket(
			'ws://' + location.host + '/' + location.search);
		sock.onopen = function()
		{
			// Ignore any attempt to clear screen if it's the first
			// message.
			ignore_disp = "\\1b[H\\1b[J";

			if (!pend_send) return;

			sock.send(pend_send);
			pend_send = '';
		};

		sock.onmessage = function(e) { display(e.data); };
	}

	prepare_sock();

	function signal(s)
	{
		if (log_send) {
			console.log('request send:', encodeURI(s));
			if (log_send > 1) console.trace();
		}

		if (sock.readyState == WebSocket.OPEN) {
			sock.send(pend_send + s);
			pend_send = '';
			return;
		}

		pend_send += s;
		if (sock.readyState > WebSocket.OPEN) prepare_sock();
	}

	t = new hterm.Terminal();
	params = new URLSearchParams(window.location.search);

	termid = params.get('termid');
	pream = params.get('pream');

	if (termid) {
		localStorage['pream-' + termid] = pream || '';

		if (localStorage['locktitle-' + termid]) {
			// This state should really live on the server in the
			// master process so it is cleared for free when the
			// process dies.
			locked_ttl = 1;
			row_ttl = localStorage['title-' + termid];
			set_title();
		}
	}

	t.setWindowTitle = function(ttl)
	{
		console.log('remotely-set title: ', ttl);
	};
	t.setWindowTitle(cached_title);


	function open_child_term()
	{
		var rand_ltr, newid;

		rand_ltr = String.fromCharCode(97 + 26*Math.random());
		newid = (termid || '') + '.' + rand_ltr;
		window.open(
			'/?termid=' + encodeURIComponent(newid) +
			'&pream=' + encodeURIComponent(pream || ''));
	}

	function open_log_term()
	{
		var pream;

		pream = 'source $WERMDIR/clean_script ' + termid + '\r';
		window.open('/?pream=' + encodeURIComponent(pream));
	}

	t.onTerminalReady = function()
	{
		var io = t.io.push();

		io.sendString = function(s) { signal(sanit(s)); };
		io.onTerminalResize = function(c, r) {
			signal('\\w' + (10000 + r + '').substr(1)
				     + (10000 + c + '').substr(1));
		};

		term_ready = true;
		display('');

		window.t = t;
	};

	t.decorate(document.querySelector('#terminal'));

	dead_key_hist = ['?', 'x', '?', 'x'];
	function push_dead_key_hist(e)
	{
		switch (e.type) {
		case 'keydown':	dead_key_hist.push('D'); break;
		case 'keyup':	dead_key_hist.push('U'); break;
		default:	dead_key_hist.push('?');
		}

		dead_key_hist.push(e.mn);
	}

	function process_key_down(e)
	{
		var ch, pref;

		if (e.altKey) return false;

		pref = e.metaKey ? '\x1b' : '';

		if (e.shiftKey && e.ctrlKey) {
			switch (e.mn) {
			case '2 ': signal(pref + '\x00'); return true;
			case '6 ': signal(pref + '\x1e'); return true;
			}
			return false;
		}

		if (e.key.length !== 1) {
			if (e.ctrlKey) {
				switch (e.mn) {
				case 'bs':	/* consume or else it makes a mess */	return true;
				case 'de':	/* consume or else it makes a mess */	return true;
				case 'me':	signal(pref + '\x1f');			return true;
				default:						return false;
				}
			}

			if (e.shiftKey) {
				switch (e.mn) {
				case 'bs': signal(pref + '\x17');		return true;	// C+W
				case 'en': signal(pref + '\x0e');		return true;	// C+N
				case 'ta': signal(pref + '\x1b\x5b\x5a');	return true;
				case 'pu':					return true;
				case 'pd':					return true;
				case 'ho':					return true;
				case 'nd':					return true;
				case 'up':					return true;
				case 'do':					return true;
				case 'le':					return true;
				case 'ri':					return true;
				default:					return false;
				}
			}

			switch (e.mn) {
			case 'up': signal(pref + '\\^');	return true;
			case 'do': signal(pref + '\\v');	return true;
			case 'ri': signal(pref + '\\>');	return true;
			case 'le': signal(pref + '\\<');	return true;
			case 'nd': signal(pref + '\\e');	return true;
			case 'ho': signal(pref + '\\h');	return true;
			case 'in': signal(pref + '\x1b[2~');	return true;
			case 'de': signal(pref + '\x1b[3~');	return true;
			case 'pu': signal(pref + '\x1b[5~');	return true;
			case 'pd': signal(pref + '\x1b[6~');	return true;
			case 'en': signal(pref + '\r');		return true;
			case 'bs': signal(pref + '\177');	return true;
			case 'es': signal(pref + '\x1b');	return true;
			case 'me': signal(pref + '_');		return true;
			case 'ta': signal(pref + '\t');		return true;
			default:				return false;
			}
		}

		if (e.ctrlKey) {
			ch = e.key.charCodeAt(0);
			if (ch >= 0x7b || ch < 0x40) return;
			if (ch >= 0x61) ch -= 0x20;
			ch -= 0x40;

			signal(sanit(pref + String.fromCharCode(ch)));
			return true;
		}

		signal(sanit(pref + e.key));
		return true;
	}

	// [0] font-family, [1] font-size (height), [2] cell-width,
	// [3] padded-cell-height, [4] allow bold face [5] 0-255 bg brightness
	// [6] 0-255 text brightness.
	// Small fonts require overriding Chrome's minimum font size setting.
	var fonts = [
		['ibm_ega_8x8',		8 ,	8 ,	9 ,	400, 26, 230],
		['hp_100lx_10x11',	12,	10,	13,	400, 26, 230],
		['jfdot_7x14',		14,	7,	14,	700, 26, 245],
		['ibm_vga_8x16',	16,	8,	16,	400, 26, 230],
		['ibm_vga_9x16',	16,	9,	16,	400, 26, 230],
		['dos_v_ibm_8x19',	20,	8,	19,	400, 26, 230],
		['cl_stringray_8x19',	20,	8,	19,	400, 26, 230],
		['ibm_xga_ai_12x23',	24,	12,	23,	400, 26, 230],
		['dos_v_re_12x30',	32,	12,	28,	700, 26, 230],
	];

	function set_font(ndx)
	{
		var f = fonts[ndx];

		t.scrollPort_.x_screen.style.fontFamily = f[0];
		t.setFontSize(f[1]);

		t.scrollPort_.characterSize = {width: f[2], height: f[3]};
		t.scrollPort_.resize();
		t.updateCssCharsize_();

		t.setCssVar('bold-weight', f[4]);

		t.setRgbColorCssVar('background-color',
				    `rgb(${f[5]}, ${f[5]}, ${f[5]})`);
		t.setRgbColorCssVar('foreground-color',
				    `rgb(${f[6]}, ${f[6]}, ${f[6]})`);
	};

	fonts.forEach(function(fnt, ndx) {
		var name = fnt[0], sz = fnt[1];
		t.document_.fonts.add(new FontFace(name, `url(/${name}.ttf)`));
		t.document_.fonts.load(`${sz}px ${name}`).then(function()
		{
			if (ndx === 4) set_font(4);
		});
	});

	var font_key;
	function set_font_key(key)
	{
		if (!/^[A-Z] $/.test(key)) return false;

		font_key = key.charCodeAt(0) - 65;
		return (font_key >= 0 && font_key < fonts.length) ? 'm' : 0;
	}
	function set_font_macro() { set_font(font_key); }

	var repeat_cnt, repsignal, repeat_boxes = [];
	const REPEAT_BOX_CNT = 8;
	function make_repeat_box(layer)
	{
		var box;

		if (repeat_boxes[layer]) return;
		repeat_boxes[layer] = box = t.document_.createElement('div');

		box.style.position = 'absolute';
		box.style.opacity = 'var(--hterm-repeat-box-opacity)';
		box.style.borderColor = `hsl(
			${layer*5%REPEAT_BOX_CNT/REPEAT_BOX_CNT * 360},
			90%, 50%)`
		box.style.borderStyle = 'solid';
		box.style.borderBottomWidth = box.style.borderTopWidth = 
			t.cursorNode_.style.height;
		box.style.borderLeftWidth = box.style.borderRightWidth = 
			t.cursorNode_.style.width;
		box.style.pointerEvents = 'none';

		layer++;
		box.style.left = `calc(
			var(--hterm-curs-left)
			- ${layer*5} * var(--hterm-charsize-width)
		)`;

		box.style.width = `calc(
			${layer*10 - 1} * var(--hterm-charsize-width)
		)`;

		box.style.top = `calc(
			var(--hterm-curs-top)
			- ${layer*5} * var(--hterm-charsize-height)
		)`;
		box.style.height = `calc(
			${layer*10 - 1} * var(--hterm-charsize-height)
		)`;

		t.scrollPort_.x_screen.appendChild(box);
	}

	function set_repeat_key(code)
	{
		var boxi, box;

		switch (code) {
		case 'bs': repsignal = '\177';		break;
		case 'vs': repsignal = '\x1b[3~';	break;
		case 'en': repsignal = '\r';		break;
		case '- ': repsignal = '-';		break;
		case 'sp': repsignal = ' ';		break;
		case 'ri': repsignal = '\\>';		break;
		case 'le': repsignal = '\\<';		break;
		case 'up': repsignal = '\\^';		break;
		case 'do': repsignal = '\\v';		break;

		default:	return 0;
		}

		for (boxi = 0; boxi < REPEAT_BOX_CNT; boxi++) {
			make_repeat_box(boxi);
			repeat_boxes[boxi].style.visibility = 'visible';
		}
		t.setCssVar('repeat-box-opacity', 0.5);

		return 'm';
	}

	function set_repeat_cnt(code)
	{
		var boxi;

		// 'me' means don't hide the guide boxes, nor repeat
		boxi = code == 'me' ? 0 : repeat_boxes.length;
		while (boxi-- > 0)
			repeat_boxes[boxi].style.visibility = 'hidden';
		// dim repeat boxes in case they are still visible
		t.setCssVar('repeat-box-opacity', 0.25);

		switch (code) {
		case 'ra': case 'me':	repeat_cnt = 0;		return 'm';
		case 'rs':		repeat_cnt = 40;	return 'm';
		}

		if (code.charAt(1) != ' ') return 0;

		repeat_cnt =
			//000000000111111111122222222223333333
			//123456789012345678901234567890123456789
			' 12345QWERTASDFGZXCVB7890-UIOP[JKL;"M,./'
			.indexOf(code.charAt(0));
		return repeat_cnt >= 1 ? 'm' : 0;
	}

	function repeat_keystroke() {
		while (repeat_cnt--) signal(repsignal);
	}

	var barrier_dig = [], barrier_div;
	function set_barrier_dig(code)
	{
		barrier_dig[this] = code[1];
		return /#[0-9]/.test(code) ? 'm' : 0;
	}
	function show_barrier()
	{
		var col, s;

		if (barrier_div) t.scrollPort_.x_screen.removeChild(barrier_div);
		barrier_div = null;

		col = Number(barrier_dig.join(''));
		if (!col) return;

		barrier_div = t.document_.createElement('div');
		s = barrier_div.style;
		s.position = 'absolute';
		s.opacity = 0.3;
		s.backgroundColor = 'hsl(' + (col * 283 % 360) + ', 90%, 50%)'
		s.left = `calc(
			var(--hterm-charsize-width) * ${col}
			+ var(--hterm-screen-padding-size)
		)`;
		s.width = 'var(--hterm-charsize-width)'
		s.top = '0';
		s.height = '100%';
		t.scrollPort_.x_screen.appendChild(barrier_div);
	}

	function match_key(exp, mn)
	{
		var res;

		switch (exp.__proto__) {
		case Function.prototype: return exp(mn);
		case Array.prototype:
			res = match_key(exp[0], mn);
			switch (res) {
			case 0: return 0;
			case 'm':
				exp = exp.slice(1);
				if (!exp.length) return 'm';
				break;
			default:
				exp = exp.slice();
				exp[0] = res;
			}
			return exp;
		case String.prototype:
			if (!exp.startsWith(mn)) return 0;
			exp = exp.substr(2);
			if (!exp.length) return 'm';
			return exp;
		}
		console.error('unknown matching kind:');
		console.log(exp, mn);
	}

	var macro_map = [
		['raW ; ', 'std::'],
		['laI F ', 'git status -s -uno\r'],
		['laI R V ', 'git remote -v\r'],
		['laI lsF ', 'git status -s -uall\r'],
		['laI D ', 'git diff '],
		['laI C O ', 'git checkout '],
		['laI C D ', 'git diff --cached '],
		['raS D ', '\x1b:w\r'],
		['raS K ', '\x1b:wq\r'],
		['laI L ', 'git log --name-status '],
		['laI T ', '|perl -pE\'/^([^0-9]*)(\\d{8,10})\\b(.*)/ and $_=$1.`date -d\\@$2 +"%F %T %Z"`."$3\\n" and s/\\n//\'|less \x01git log --graph --format="%ct %h %s" '],
		['laI B R ', 'git branch '],
		['laI C M ', 'git commit '],
		['laI P S ', 'git push '],
		['laI P L ', 'git pull '],
		['lavsU ', '| grep '],
		['raD G ', 'grep -Irn '],
		['laI S ', 'git show '],
		['laH T ', open_child_term],
		['la; P ', ':e %:p:h\t'],
		['la; [ ', ':e \x12%'],
		['raR S E ', 'sudo shutdown -r now; exit\r'],
		[['raF N ', set_font_key], set_font_macro],
		['ralsI ', '\x1bI'],
		['ralsE ', '\x1bA'],
		['raA ', '->'],
		['raT ', '\x14'],
		['ralsT ', '\x1b\x14'],
		['raD U M P ', signal.bind(0, '\\d')],
		['raS T ', set_locked_title],
		['laU T ', unlock_title],

		[['ra', set_repeat_key, set_repeat_cnt], repeat_keystroke],
		[['la',
		 set_barrier_dig.bind(0),
		 set_barrier_dig.bind(1),
		 set_barrier_dig.bind(2)], show_barrier],
	];

	if (termid) macro_map.push(['laH L ', open_log_term]);

	function collect_macros(name)
	{
		var map = window.extended_macros[name] || [];
		while (map.length) macro_map.push(map.pop());
	}

	collect_macros('gum');
	collect_macros('local');

	var got_key_up = false, matching = [], macro_winpos;

	function winpos() { return window.screenX + 'x' + window.screenY; }
	function process_mkey(e)
	{
		var mi, mch, mac, save, is_alt;

		is_alt = (e.mn == 'la' || e.mn == 'ra');

		if (e.key == 'Meta' && e.altKey) {
			// Alt+Meta+M to switch monitors should not be considered
			// the start of a macro.
			matching.length = 0;
			if (log_macks)
				console.log('Ignore Meta for second macro key');
			return false;
		}

		if (!matching.length) {
			if (!is_alt) return false;
			got_key_up = false;
			macro_winpos = winpos();
			if (log_macks) console.log('start of macro: ', e);
		}
		else if (!got_key_up && is_alt) {
			// Ignore holding down Alt key, or starting a macro
			// right after an Alt+<ash keybinding>.
			matching = [];
			if (log_macks)
				console.log('macro reset (hold alt): ', e);
		}
		else if (!got_key_up && !e.altKey) {
			// We never received Alt release event, but the current
			// event doesn't have the altKey bit set.
			// Chrome may have hid the event from us, indicating an
			// Ash shortcut was activated, so we don't consider
			// macros.
			// On Lacros this seems to have changed. The Alt Key up
			// event is still received.
			matching.length = 0;
			if (log_macks)
				console.log('macro reset (missed alt up)', e);
			return false;
		}
		else if (log_macks)
			console.log('process macro', e, matching);

		if (!matching.length)
			for (mi = 0; mi < macro_map.length; mi++)
				matching.push(macro_map[mi].slice());

		for (mi = 0; mi < matching.length; mi++) {
			mac = matching[mi];
			if (log_matching) console.log('match against:', mac);
			switch (mac[0] = match_key(mac[0], e.mn)) {
			case 0:
				save = matching.pop();
				if (mi < matching.length) matching[mi--] = save;
				break;
			case 'm':
				mch = mac[1];
				if (typeof mch === 'string')
					signal(sanit(mch));
				else if (typeof mch === 'function')
					mch();
				else {
					console.error('unknown mapping type:');
					console.log(mch);
				}
				matching.length = 0;
				return true;
			}
		}

		if (!matching.length) {
			// Neither a full match nor a prefix match.
			console.warn('no matching macro');
			signal('?');
		}
		return true;
	}

	t.getScrollPort().getDocument().body.onkeydown = function(e)
	{
		var ce;

		if (log_keys) console.log('scrollport key:', e);

		ce = cookev(e);

		// Let search+right alt (in that order) turn on capslock.
		if (ce.mn == 'ra' && ce.metaKey) return;

		if (!process_mkey(ce)) {
			push_dead_key_hist(ce);
			dead_key_hist.splice(0, 2);

			if (!process_key_down(ce)) return;
		}
		e.stopPropagation();
		e.preventDefault();
	};

	t.getScrollPort().getDocument().body.onkeyup = function(e)
	{
		var hist;

		if (log_keys) console.log('scrollport key:', e);

		if (matching.length) {
			if (macro_winpos != winpos()) {
				matching.length = 0;
				return;
			}
			// Don't consider Tab to validate the start of a macro,
			// as this would only be useful if the user pressed:
			//	1. AltDown
			//	2. TabDown
			//	3. TabUp
			// But this would just activate the Alt+Tab shortcut to
			// switch windows.
			if (e.code != 'Tab') got_key_up = true;
			if (log_macks)
				console.log('check key up', got_key_up, e);
			return;
		}

		e = cookev(e);
		push_dead_key_hist(e);
		hist = dead_key_hist.join('');
		dead_key_hist.splice(0, 2);

		if (hist.endsWith('DlsUls') || hist === 'DlsDrsUls' || hist === 'DlsUrsUls') signal(')');
		if (hist.endsWith('DrsUrs') || hist === 'DrsUlsUrs' || hist === 'DrsDlsUrs') signal('(');
		if (hist.endsWith('DrcUrc')) signal('$');
		if (hist.endsWith('DlcUlc')) signal('"');
	};
}

window.onload = function()
{
	lib.init().then(term_init);
};
    </script>
  </body>
</html>
